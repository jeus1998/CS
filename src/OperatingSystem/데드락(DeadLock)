
참고 자료 : [쉬운코드] https://www.youtube.com/watch?v=ESXCSNGFVto&list=PLcXyemr8ZeoT-_8yBc_p_lVwRRqUaN8ET&index=14

1. 데드락(deadlock)의 개념 이해
2. os에서 데드락 해결 방법
3. 프로그래밍에서 데드락 해결 방법

DeadLock(교착상태)
- 두 개 이상의 프로세스/스레드가 서로가 가진 리소스를 기다리는 상태

데드락을 만드는 네 가지 조건

1. Mutual Exclusion 상호 배제
- 리소스(resource)를 공유해서 사용할 수 없다.

2. Hold and wait
- 프로세스가 이미 하나 이상의 리소스를 취득한(hold) 상태에서 다른 프로세스가 사용하고 있는 리소스를 추가로 기다린다(wait)

3. No preemption
- 리소스 반환(release)는 오직 그 리소스를 취득한 프로세스만 할 수 있다.

4. Circular wait
- 프로세스들이 순환(circular) 형태로 서로의 리소스를 기다린다.

OS에서 데드락을 해결하는 방법

1. 데드락 방지
2. 데드락 회피
3. 데드락 감지와 복구
4. 데드락 무시

##데드락 방지(Deadlock prevention)
- 네 가지 조건 중 하나가 충족되지 않게 시스템을 디자인

데드락 방지 #1 mutual exclusion
- 리소스를 공유 가능하게 함 <- 현실적으로 불가능하다. 동기화의 중요성

데드락 방지 #2 hold and wait
- 사용할 리소스들을 모두 획득한 뒤에 시작
- 리소스를 전혀 가지지 않은 상태에서만 리소스 요청

2가지 문제점
- 사용할 리소스가 인기가 많은 리소스라면 계속 기다려야 한다. (starvation - 프로세스가 cpu 할당을 무한정 대기)
- 만약 사용할 리소스가 2개(1r, 2r) 1r을 처리하는데 오래 걸린다면 2r은 계속 놀고 있는다. (리소스 사용 효율이 떨어진다)

데드락 방지 #3 no preemption
- 추가적인 리소스를 기다려야 한다면 이미 획득한 리소스를 다른 프로세스가 선점 가능하도록 한다.

비슷한 사례들
ex2) 컨텍스트 스위칭 - 프로세스가 할일을 진행 하다가 cpu time이 끝나면 프로세스를 중단하고 다음 프로세스로 컨텍스트 스위칭
ex2) 모니터 - mutex lock을 확보한 스레드가 어떤 특정한 조건이 맞지 않으면 wait()를 하면서 다시 mutex lock 반환

데드락 방지 #4 circular wait
- 모든 리소스에 순서 체계를 부여해서 오름차순으로 리소스를 요청
- 가장 많이 사용하는 데드락 방지 방법

##데드락 회피(Deadlock avoidance)
- 데드락 방지는 시스템 레벨에서 데드락이 발생하는 조건을 미리 없애는 방법
- 데드락 회피는 실행 환경에서 추가적인 정보를 활용해서 데드락이 발생할 것 같은 상황을 회피하는 것

추가적인 정보?
- 현재 사용 가능한 리소스, 이미 할당된 리소스, 미래에 사용할 리소스, 권한 등...

Banker Algorithm
- 리소스 요청을 허락해줬을 때 데드락이 발생할 가능성이 있으면 리소스를 할당해도 안전할 때 까지 계속 요청을 거절하는 알고리즘

##데드락 감지와 복구
- 데드락을 허용하고 데드락이 발생하면 복구하는 전략

복구 전략 2가지
1. 프로세스를 강제로 종료한다. (리스크가 큰 방법) ex) 이미 서버에서는 데드락이 발생하여 정상 동작을 못하면 인스턴스를 내리고 새로운 인스턴스 올리기
2. 리소스의 일시적인 선점을 허용한다.

##데드락 무시
아몰랑 개발자가 알아서 하겠지...?
-> 은근 많은 os가 이런 전략을 사용한다 ㅋㅋ

이제 자바로 살펴보는 프로그래밍 레벨에서 데드락을 보자 -> OperatingSystem/Deadlock_Java
