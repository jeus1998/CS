
# 컨테스트 스위칭, PCB, TCB

### 참고 자료 

[쉬운 코드] https://www.youtube.com/watch?v=Xh9Nt7y07FE&list=PLcXyemr8ZeoQOtSUjwaer0VMJSMfa-9G-&index=2

[내가 예전에 정리한 티스토리] https://20240228.tistory.com/98

[sweet_sumin.log]https://velog.io/@sweet_sumin/PCBTCB

### 프로세스, 스레드 구조

![9.JPG](Image%2F9.JPG)

## PCB(Process Control Block)

- 운영체제가 프로세스를 제어하기 위해 정보(CPU 레지스터 값들)를 저장해 놓는 곳
  - 프로세스의 상태 정보를 저장하는 구조체
- 운영체제가 프로세스 스케줄링을 위해 프로세스에 관한 모든 정보를 가지고 있는 데이터베이스
- 각 프로세스가 생성될 때마다 고유의 PCB가 생성되고, 프로세스가 완료되면 PCB는 제거된다.
- 프로세스는 CPU를 점유하여 작업을 처리하다가도 상태가 전이되면, 진행하던 작업 내용들을 모두 정리하고 CPU를 반환해야 하는데
  이때 진행하던 작업들을 모두 저장하지 않으면 다음에 자신의 순서가 왔을 때 어떠한 작업을 해야하는지 알 수 없는 사태가 발생한다.
  프로세스는 CPU가 처리하던 작업의 내용들을 자신의 PCB에 저장하고, 다음에 다시 CPU를 점유하여 작업을 수행해야 할 때 
  PCB로부터 해당 정보들을 CPU에 넘겨와서 계속해서 하던 작업을 진행할 수 있게 된다.
- PCB 는 프로세스의 중요한 정보들을 담고 있으므로 일반 사용자는 접근하지 못하는 보호된 메모리 영역에 존재

### PCB(Process Control Block) 저장 정보 

![10.JPG](Image%2F10.JPG)

- 프로세스 식별자(Process ID) : 프로세스 고유 번호
- 프로세스 상태(Process State)
  - 생성(create)
  - 준비(ready)
  - 실행(running)
  - 대기(waiting)
  - 완료(terminated)
- 프로그램 계수기(Program Counter)
  - 프로그램 계수기는 이 프로세스가 다음에 실행할 명령어의 주소를 가리킵니다.
- CPU 레지스터 및 일반 레지스터
  - CPU가 요청을 처리하는 데 필요한 데이터를 일시적으로 저장하는 기억장치
- CPU 스케줄링 정보
  - 우선 순위, 최종 실행시각, CPU 점유시간 등
- 메모리 관리 정보
  - 해당 프로세스의 주소 공간 등
- 입출력 상태 정보
  - 프로세스에 할당된 입출력장치 목록, 열린 파일 목록 등
- 프로세스 계정 정보
  - 페이지 테이블, 스케줄링 큐 포인터, 소유자, 부모 등
- 포인터
  - 부모프로세스에 대한 포인터
  - 자식 프로세스에 대한 포인터
  - 프로세스가 위치한 메모리 주소에 대한 포인터
  - 할당된 자원에 대한 포인터 정보
  - 프로세스가 준비상태나 대기 상태일 경우에 큐로 운영이 되는데 프로세스 제어 블록을 연결 시 큐로 구현하기 위해 포인터를 사용한다.

### 운영체제의 PCB 관리 테이블

![11.JPG](Image%2F11.JPG)

- 운영체제는 빠르게 PCB에 접근하기 위해 프로세스 테이블을 사용하여 각 프로세스의 PCB를 관리한다

![12.JPG](Image%2F12.JPG)

- 프로세스는 각각의 프로세스 이미지를 가진다. 프로세스 이미지는 데이터, 프로그램, 스택, PCB를 가진다.

## TCB (Thread Control Block)

- TCB는 PCB보다 적은 데이터를 가지는 자료구조이다.
- 같은 프로세스의 Code, Data, Heap 영역 공유 
- stack 영역 따로 갖는다.

### TCB (Thread Control Block) 저장 정보 

- 스레드 ID : 스레드가 생성될 때 운영 체제에서 스레드에 할당하는 고유 식별자
- 스레드 상태: 스레드가 시스템을 통해 진행됨에 따라 변경되는 스레드의 상태
- CPU 정보: 스레드가 얼마나 진행되었는지, 어떤 데이터가 사용되고 있는지 등 OS가 알아야 하는 모든 정보가 포함
- 우선 순위: 스레드 스케줄러가 READY 대기열에서 다음에 선택해야 하는 스레드를 결정하는 데 도움이 되는 
  다른 스레드에 대한 스레드의 가중치(또는 우선 순위)
- PCB를 가리키는 포인터 : 이 스레드 생성을 트리거한 프로세스를 가리키는 포인터
- 이 스레드가 생성한 스레드를 가리키는 포인터
- stack 포인터 ( stack : 스레드가 함수 호출할때 저장하는 곳)

⭐️ 메모리영역 중 PCB는 커널 영역TCB는 유저영역과 커널 영역에 둘다 있을 수 있다.

## 컨테스트 스위칭(context switching)

- CPU/코어에서 실행 중이던 프로세스/스레드가 다른 프로세스/스레드로 교체되는 것
  - 오늘날 cpu 실행 단위는 스레드이다. 그래서 프로세스 컨텍스트 스위칭 p1스레드에서 ➡️ p2스레드로 교체 
- 컨텍스트(context)
  - 프로세스/스레드 상태
  - CPU(레지스터), 메모리

### 컨테스트 스위칭은 왜 필요한가?

- 여러 프로세스/스레드를 동시에 실행시키기 위해서

### 컨테스트 스위칭은 언제 발생하는가?

- 주어진 time slice(quantum)룰 다 사용 
- IO 작업 수행 
- 다른 리소스를 wait

### 멀티태스킹 시스템에서 컨텍스트 스위칭 

![8.JPG](Image%2F8.JPG)

### 컨텍스트 스위칭은 누구에 의해 실행되는가?

OS 커널(kernel) 
- 각종 리소스를 관리/감독하는 역할 
- 컨텍스트 스위칭은 kernel이 통제권을 가지고 집행한다.
- OS의 핵심

### 컨텍스트 스위칭은 구체적으로 어떤 과정으로 일어나는가?

- 다른 프로세스끼리 스위칭인지 ➡️ 프로세스 컨텍스트 스위칭 
- 같은 프로세스 스레드들끼리 스위칭인지에 따라 다르다 ➡️ 스레드 컨텍스트 스위칭

### 프로세스 컨텍스트 스위칭과 스레드 컨텍스트 스위칭 공통점?

- 커널 모드 실행
  - 프로세스가 컴퓨터의 리소스에 접근을 하려면 프로세스가 직접 접근을 하는게 아니라
    운영체제를 통해서 접근을 하는데 이때 운영체제의 커널을 통해서 접근을 한다.
  - 이때 커널에게 통제권이 넘어가고 커널에서 실행되는 구간을 커널 모드라고 표현 한다.
- 레지스터 상태 교체
  - CPU에는 여러가지 레지스터가 있다. 이 레지스터들은 각종 명령어를 수행하기 위해 여러 데이터들을 저장하는 존재이다.
  - 프로세스1 ➡️ 프로세스2 컨텍스트 스위칭이 발생하면 프로세스1의 상태를 레지스터에 저장 
  - 저장을 하는 이유는 다른 프로세스가 실행이 끝나고 프로세스1이 실행되면 프로세스1이 동작이 끝난 부분부터 시작하기 위해서 

### 프로세스 컨텍스트 스위칭과 스레드 컨텍스트 스위칭 차이점?

- 프로세스 컨텍스트 스위칭은 가상(virtual) 메모리 주소 관련 처리를 추가로 수행 
  - 서로 다른 프로세스는 메모리 주소 체계가 다르다.
  - MMU가 새로운 프로세스의 메모리 주소 체계를 바라보도록 변경 
  - TLB라고 불리는 가상 메모리 주소와 실제 메모리 주소를 매핑 정보를 들고 있는 캐시를 비워준다.

### 스레드 컨텍스트 스위칭 진행 과정

- 유저 모드 ➡️ 커널 모드 
- 현재 실행 중인 스레드 자신의 상태를 TCB에 저장 
- 스케줄러가 다음 실행할 스레드 선택
- 선택된 스레드의 TCB 로드 
- 해당 스레드의 상태 복원 & 실행 
- 커널 모드 ➡️ 유저 모드 

### 프로세스 컨텍스트 스위칭 진행 과정

- 유저 모드 ➡️ 커널 모드 
- 현재 실행 중인 프로세스 자신의 상태를 PCB에 저장 
- 스케줄러가 다음 실행할 프로세스 선택
- MMU: 새로운 가상 주소 공간 설정 
  - 같은 공간의 스레드 컨텍스트 스위칭과 달리 서로 다른 프로세스은 메모리 주소 체계가 다름 
- TLB: 새로운 페이지 테이블 정보를 로드 주소 변환 수행 
- 선택된 프로세스의 PCB 로드
- 해당 프로세스의 상태 복원 & 실행 
- 커널 모드 ➡️ 유저 모드 

### 스레드 컨텍스트 스위칭이 더 빠른 이유

- 메모리 주소 관련 처리는 하지 않기 때문
- CPU 상태정보만 교체 (TCB)

### 컨텍스트 스위칭이 미치는 간접적인 영향?

- 캐시(cache) 오염(pollution)
  - 스레드 컨텍스트 스위칭은 그나마 덜하다.
  - 프로세스 컨텍스트 스위칭은 프로세스끼리 공유되는 데이터가 아예 없다.
  - 프로세스 컨텍스트 스위칭이 일어나면 cache에 있는 데이터들은 이미 이전 프로세스(스레드)의 데이터가 있어서 
    결국 CPU가 Memory까지 가야 한다. (성능에 안 좋다!)

### 유저 관점에서 컨텍스트 스위칭이란?

- 순수한(pure) 오버헤드 (overhead)
- 자주 발생하면 성능 저하 


