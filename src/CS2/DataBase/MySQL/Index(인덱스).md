# 인덱스 

### 인덱스란? 

- 인덱스는 데이터베이스에서 데이터를 조회할 때 결과를 빠르게 추출하도록 도와주는 하나의 데이터베이스 개체 
- 사전의 '찾아보기' 같은 역할을 한다 
- 인덱스에 따른 결과 값에 차이는 없고 단지 조회 성능을 개선하는 용도로 사용된다. 
- 실무에서는 인덱스 없이 DB 운영이 불가능하다. 
- 인덱스가 있다고 무조건 좋은 것은 아니다. 
  - 추가적인 DB 공간 필요, 데이터 작업 변경(UPDATE, DELETE) 작업시 오히려 성능 저하
  - 꼭 필요한 컬럼에 인덱스를 생성해야한다. 

### 인덱스 특징 

- 장점
  - 적절한 인덱스를 생성하고 사용하면 조회 성능을 획기적으로 개선할 수 있다. 
  - 검색 속도 향상 & 시스템 성능 향상 
- 단점
  - 인덱스는 대략 테이블 크기의 10% 공간이 추가로 필요(인덱스 페이지)
  - 데이터의 변경 작업(INSERT, UPDATE, DELETE)이 자주 일어나면 오히려 성능에 악영향 (페이지 정렬 작업)

### 인덱스 종류 

- 클러스터형 인덱스(Clustered Index)
  - 테이블당 1개만 존재 
  - 기본 키로 지정된 컬럼은 자동으로 클러스터링 인덱스가 생성
  - 실제 저장된 데이터와 같은 무리(클러스터, 군집)의 페이지 구조를 가짐 
  - 클러스터링 인덱스를 기준으로 데이터가 ``자동 정렬``
  - 기본 키를 변경하면 클러스터링 인덱스가 변경되기 떄문에 변경된 기본 키를 기준으로 자동 정렬 
- 보조 인덱스(Secondary Index/ non-Clustered Index)
  - 한 테이블에 여러개 설정 가능 
  - UNIQUE 키워드로 고유 컬럼 저장시 자동으로 보조 인덱스가 생성
  - 실제 저장된 데이터와 다른 무리(cluster)의 별도의 페이지 구조를 가짐 
  - 클러스터링 인덱스와 달리 데이터를 정렬하지 않음 
  - ``CREATE INDEX``문으로 직접 보조 인덱스 생성 가능 

### 클러스터(Cluster) 개념 

- 데이터가 군집(클러스터)으로 묶여서 저장되는 것을 의미 
- 예전에 해시 충돌에서 해결 방법으로 나온 OpenAddressing 문제점으로 나온 개념 
- 클러스터형 인덱스 저장 방식 -> 논리적 인접성 
- 연속적인 저장: 배열처럼 물리적으로 연속적으로 저장되는 것은 아니지만 논리적으로 인접한 데이터가 
  인접한 페이지에 저장되도록 최적화된다. 

### 인덱스 동작 원리

- 클러스터링 인덱스, 보조 인덱스 모두 내부적으로 균형 트리(B-tree)로 만들어진다. 
- 노드: 균형 트리 구조에서 데이터가 저장되는 공간을 말함
  - 위치에 따라서 루프 노드, 중간 노드, 리프 노드로 구성 
  - MySQL에서는 이러한 노드들을 페이지 라고 부른다. 
- 균형 트리(B-tree)는 데이터를 검색할 때 아주 뛰어난 성능을 발휘한다. 
- 데이터 검색 과정 
  - 데이터 검색 시작 -> 루트 페이지에서 검색할 데이터가 몇 번 페이지에 있나 탐색 -> 해당 페이지 확인, 추출 
  - 이런 과정에서 몇 개의 페이지를 읽었는지에 따라 효율성을 판단할 수 있다. 
- MySQL에서는 페이지를 나누어 데이터를 저장
  - 페이지는 최소 16KB의 크기를 가진다. 
  - 페이지 데이터 공간이 추가로 필요할 경우 페이지 분할 작업을 통해 페이지 생성을 하고 각 페이지에 데이터를 분할 

클러스터형 인덱스 구조 
![1.JPG](Image%2F1.JPG)
- 클러스터형 인덱스 페이지는 루트 - (중간) - 리프 페이지로 이루어져 있다. 
- 클러스터형 인덱스가 걸린 기본 키를 기준으로 실제 데이터가 정렬된다. 
- 클러스터형 인덱스는 리프 노드가 곧 데이터 페이지(실제 데이터가 저장된 위치)이다.
- 클러스터형 인덱스를 통해 검색시 먼저 루트 노드에서 탐색할 페이지를 찾고 해당 페이지에서 검색할 데이터를 찾게 됨으로써
  검색 시간을 줄이게 된다. 

페이지 분할 
![2.png](Image%2F2.png)

- 인덱스를 구성하면 데이터 변경 작업(INSERT, UPDATE, DELETE)시 성능이 나빠진다.
- 특히 INSERT 영향이 큰데, 그 이유는 페이지 분할 작업이 발생하기 때문이다. 
- 페이지 분할 작업이 자주 일어나면 데이터베이스에 성능에 큰 영향을 미친다. 

보조 인덱스 페이지 구조 
![3.png](Image%2F3.png)

- 보조 인덱스 페이지는 실제 데이터를 정렬하지 않는다. 따라서 보조 인덱스를 설정해도 데이터 페이지는 
  아무런 영향이 없고 별도의 장소에 인덱스 페이지를 생성한다.
- 클러스터링 인덱스와 같이 리프 페이지를 사용하게 될 경우 클러스터링 인덱스로 인해 정렬된 데이터 페이지를 
  가리키게 된다. 

### 인덱스 사용법 

인덱스 또한 데이터베이스 개체이다. 따라서 CREATE, DELETE를 통해서 인덱스를 생성 및 제거할 수 있다.

자동 생성 
- 클러스터형 인덱스 
  - PK로 지정(우선순위)/ UNIQUE + NOT NULL 제약 조건
- 비클러스터형 인덱스(보조 인덱스)
  - UNIQUE 제약 조건 

직접 인덱스 생성(MySQL에서는 클러스터형 인덱스가 1개만 존재 즉 직접 인덱스 생성은 비클러스터형 인덱스)
```sql
CREATE [UNIQUE] INDEX 인덱스_이름
	ON 테이블_이름 (열 이름) [ASC | DESC]
```
- UNIQUE 옵션은 중복이 안되는 고유 인덱스를 생성 생략하면 중복이 허용 
- ASC OR DESC로 인덱스의 정렬 방향을 변경 가능 
  - DESC로 만드는 경우는 거의 없다.

인덱스 제거
```sql
DROP INDEX 인덱스_이름 ON 테이블_이름
```
- 기본 키(PK), 고유 키(UNIQUE)로 자동 생성된 인덱스는 DROP INDEX로 제거 불가능 
  - ALTER TABLE을 통해 기본 키나 고유 키를 제거하면 자동으로 생성된 인덱스도 제거 가능 
- 인덱스를 제거할 때는 보조 인덱스부터 제거하는 것이 더 좋다.
- 인덱스가 많이 생성되어 있는 테이블의 경우 사용하지 않는 인덱스는 제거하자 
  - 인덱스 또한 메모리를 사용하는 개체(테이블의 약 10%)

인덱스 적용 
```sql
ANALYZE TABLE [테이블이름];
```
- 테이블 구문 분석/처리를 통해 인덱스 적용 

인덱스 확인 
```sql
SHOW INDEX FROM [테이블이름];
```
![4.JPG](Image%2F4.JPG)

인덱스를 사용한 조회 
```sql
SELECT 컬럼1, 컬럼2, ...
FROM [테이블이름]
WHERE [인덱스가 생성된 컬럼] = condition;
```

### 인덱스가 사용되지 않는 경우

인덱스 조건 누락
```sql
SELECT * FROM [테이블이름];
```
- 인덱스가 설정된 컬럼을 조건으로 걸지 않았을 경우, 테이블에 인덱스가 존재하더라도 Full Table Scan이 발생

전체 테이블 검색이 더 빠른 경우 
```sql
SELECT * FROM [테이블 이름]
    WHERE PK >= 1;
```
- PK 1부터 시작 가정 
- 테이블에 저장된 모든 PK는 1이상 따라서 전체가 조회 
- 인덱스가 설정된 컬럼을 조건에 걸었더라도 인덱스를 사용하여 데이터를 추출하는 것 보다 전체 테이블을 탐색하는 것이
  더 빠른 경우가 있다. 
- MySQL은 인덱스를 사용할지, 전체 테이블을 탐색할지 판단하고 해당 방식을 사용하여 데이터를 조회 

인덱스가 사용된 컬럼에 연산을 가할 경우 
```sql
# 인덱스 사용 X
SELECT *
FROM [테이블 이름]
WHERE LENGTH(인덱스 컬럼(VARCHAR(100)) + '1') >= 5;

# 인덱스 사용 O
SELECT *
FROM [테이블 이름]
WHERE LENGTH(인덱스 컬럼(VARCHAR(100))) >= 5 - 1;
```
- 인덱스는 가공된 데이터를 저장하고 있지 않기 때문에 컬럼에 연산이 가해지면 인덱스를 사용한 데이터 조회가 불가능
- 컬럼에 직접적인 연산을 가하지 않는 방식으로 사용해야한다. 

### 인덱스 사용시 유의사항 

카디날리티(cardinality)가 높은 (중복도가 낮은) 열에 인덱스를 설정해야 한다.
- 카디널리티: 데이터베이스 테이블의 특정 열에 포함된 데이터 값의 고유성
- 인덱스는 중복도가 높은 컬럼에 설정할 경우, 별다른 성능 향상의 결과를 얻지 못하기 때문에 중복도가 낮은 컬럼에 설정

WHERE 절에 자주 사용되는 열에 인덱스를 만들어야 한다.
- WHERE 절에 사용되는 열에 따라 테이블 스캔 방식이 변경됩니다. WHERE 절에 자주 사용되지 않는 열에 인덱스를 설정하였다면 인덱스를 실제로 활용할 일이 적다는 뜻으로, 
  다른 열에 인덱스를 설정하는 것이 좋다

잘 사용되지 않는 인덱스는 과감히 제거
- 인덱스는 테이블 데이터의 약 10% 정도를 차지하는 데이터베이스 개체
- 데이터 변경 작업시 페이지 분할 작업으로 인해 성능에 악영향을 미칠 수 있다.


INSERT, UPDATE, DELETE 등의 데이터 작업이 빈번한 테이블에서는 인덱스 사용을 고려
- 데이터 변경 작업(INSERT, UPDATE, DELETE)이 자주 발생한다면 페이지 분할 작업으로 인해 조회 성능을 제외한 다른 작업 성능이 느려지게 된다.
- 데이터 변경 작업이 빈번한 테이블이라면 인덱스를 설정하지 않음으로써 조금 느린 조회 속도를 감수하는 것도 하나의 방법


### 참고 자료
- [기억의 정류장](https://rachel0115.tistory.com/entry/MySQL-%EC%9D%B8%EB%8D%B1%EC%8A%A4-INDEX-%EC%A0%95%EB%A6%AC-%EB%8F%99%EC%9E%91-%EB%B0%A9%EC%8B%9D-%EC%83%9D%EC%84%B1-%EC%82%AD%EC%A0%9C-%EC%84%A4%EA%B3%84)


